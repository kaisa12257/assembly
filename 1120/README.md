8장에서는
참조 방식으로 전달되는 인수는 객체의 주소(오프셋)로 구성되며 호출된 서브루틴이 원래 변수의 값을 직접 수정할 수 있게 하는 방식입니다.
그리고 레지스터는 함수 호출 전에 현재 레지스터 값이 사라지면 안 되므로 EBX, ECX, ESI 같은 레지스터를 미리 스택에 저장(push) 해야 합니다.
어셈블리에서 프로시저 호출 시 인수(arguments) 는 스택에 push 되어 전달되고프로시저 내부에서는 EBP 기반(base-offset) 주소 방식으로 접근한다.
Push Arguments는
함수에 전달할 인자(파라미터)를 스택에 push 합니다.
그리고 Register Parameters의 단점으론
서브루틴(프로시저)에 인수를 레지스터로 전달할 경우, 호출하는 쪽에서는 다음 문제들이 생긴다는 것이다.
1. 기존 레지스터 값을 보존해야 한다
프로시저에 인수로 사용하려는 레지스터에는 원래 사용 중이던 값이 있을 수 있으므로,
push 명령으로 스택에 저장해 두었다가, 호출 후 pop으로 복구해야 한다. 또한
push 명령으로 값(val1, val2)을 스택에 복사해서 넣는다
고급 언어는 배열을 항상 참조 방식으로 서브루틴에 전달한다.
즉, 배열의 주소를 스택에 푸시한다. 스택 매개변수를 [ebp + 8] 같은 표현으로 참조할 때, 이를 명시적 스택 매개변수라고 부른다. 일부 프로그래머들은 명시적 스택 매개변수를 더 읽기 쉽게 만들기 위해 상수 심볼을 정의한다.
C 호출 규약에서는 C 및 C++ 프로그래밍 언어에서 사용된다.
서브루틴의 매개변수는 스택에 역순으로(push) 저장된다.
stdcall은 Windows API 등에서 많이 사용하는 함수 호출 규약(calling convention) 입니다.
이 규약의 핵심 특징은:
매개변수(arguments)는 스택에 올려서 전달
스택 정리는 함수(피호출자, callee)가 책임
ret N 형태로 돌아가며 스택에서 N 바이트 제거
또한 
INVOKE 는 32비트 MASM에서만 사용 가능한 호출 명령으로,
함수(프로시저)를 호출하면서
인자(파라미터)를 스택에 자동으로 push 해주고
CALL 까지 자동으로 실행해준다.
