1-a
6Ah
1-b
EAh
1-c
FDh
1-d
A9h
2-a
9Ah
2-b
6Ah
2-c
A9h
2-d
F5h
3	AX = 2200h , DX = 0002h
4	AX = 0006h , DX = 0003h
5	EAX = 0012340h , EDX = 00000000h
6	AX = 0400h , DX = 0000h
7	BX = 0066h
8	RAX = 0000000000000000h , RDX = 0000000000000020h
9	result = 01AEEFCF393DF4EFh
10	RAX = 0004080C10140000h
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
1	
shl eax,16
sar eax,16
2	
shr al,1
jnc skip
or al,80h
skip:
3	
shl eax,4
4	
shr ebx,2
5
rol dl,4
6
shld dx,ax,1
7	
mov al,byteArray+2
shr al,1
mov byteArray+2,al
mov al,byteArray+1
rcr al,1
mov byteArray+1,al
mov al,byteArray
rcr al,1
mov byteArray,al
8	
mov ax,wordArray
shl ax,1
mov wordArray,ax
mov ax,wordArray+2
rcl ax,1
mov wordArray+2,ax
mov ax,wordArray+4
rcl ax,1
mov wordArray+4,ax
9	
mov ax,5
mov bx,3
mul bx
mov val1,ax
10	
mov ax,276
mov bl,10
div bl
mov val1,ax
11	
mov eax,val2
mul val3
mov ebx,val4
sub ebx,3
div ebx
mov val1,eax
12	
mov eax,val2
cdq
idiv val3
add val1,val2
imul eax,val1
mov val1,eax
13	
mov bl,10
div bl
add al,'0'
call WriteChar
mov al,ah
add al,'0'
call WriteChar
14	 
AAA 출력값 → AX = 0102h
15	
mov eax,n
and eax,(y-1)
mov x,eax
16	
mov edx,eax
sar edx,31
xor eax,edx
add eax,edx
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
1.
WriteScaled PROC
    push eax
    push ecx
    push ebx
    push edx
    mov eax,ecx
    sub eax,ebx
    mov esi,edx
    xor edi,edi
L1:
    cmp edi,eax
    jne L2
    mov al,'.'
    call WriteChar
L2:
    cmp edi,ecx
    jge L3
    mov al,[esi+edi]
    call WriteChar
    inc edi
    jmp L1
L3:
    pop edx
    pop ebx
    pop ecx
    pop eax
    ret
WriteScaled ENDP
2.
Extended_Sub PROC
    push eax
    push ebx
    push ecx
    push esi
    push edi
    push edx
    clc
    dec ecx
L1:
    mov al,[esi+ecx]
    mov bl,[edi+ecx]
    sbb al,bl
    mov [edx+ecx],al
    or ecx,ecx
    jz L2
    dec ecx
    jmp L1
L2:
    pop edx
    pop edi
    pop esi
    pop ecx
    pop ebx
    pop eax
    ret
Extended_Sub ENDP
3.
PackedToAsc PROC
    push eax
    push ebx
    push ecx
    push esi
    push edi
    mov ecx,4
L1:
    mov al,[esi]
    mov bl,al
    shr al,4
    add al,'0'
    mov [edi],al
    and bl,0Fh
    add bl,'0'
    mov [edi+1],bl
    inc esi
    add edi,2
    loop L1
    mov byte ptr [edi],0
    pop edi
    pop esi
    pop ecx
    pop ebx
    pop eax
    ret
PackedToAsc ENDP
4.
Encrypt PROC
    push eax
    push ebx
    push edx
    xor edi,edi
L1:
    cmp edi,ecx
    jge L2
    mov eax,edi
    mov ebx,10
    xor edx,edx
    div ebx
    mov bl,key[edx]
    mov al,[esi+edi]
    cmp bl,0
    je L3
    jl L4
    mov cl,bl
    ror al,cl
    jmp L5
L4:
    neg bl
    mov cl,bl
    rol al,cl
    jmp L5
L3:
    nop
L5:
    mov [esi+edi],al
    inc edi
    jmp L1
L2:
    pop edx
    pop ebx
    pop eax
    ret
Encrypt ENDP
5.
mov ecx,1001
mov esi,OFFSET isPrime
mov al,1
rep stosb
mov byte ptr isPrime,0
mov byte ptr isPrime+1,0
mov ebx,2
L1:
    cmp ebx,32
    jg L3
    cmp byte ptr isPrime[ebx],1
    jne L2
    mov edx,ebx
    imul edx,ebx
L4:
    cmp edx,1000
    jg L2
    mov byte ptr isPrime[edx],0
    add edx,ebx
    jmp L4
L2:
    inc ebx
    jmp L1
L3:
    mov ebx,2
L5:
    cmp ebx,1000
    jg L6
    cmp byte ptr isPrime[ebx],1
    jne L7
    mov eax,ebx
    call WriteInt
    call Crlf
L7:
    inc ebx
    jmp L5
L6:
6.
GCD PROC
    push ebx
    push ecx
    push edx
    cmp eax,0
    jge L1
    neg eax
L1:
    cmp ebx,0
    jge L2
    neg ebx
L2:
L3:
    cmp ebx,0
    je L4
    mov edx,0
    div ebx
    mov ecx,eax
    mov eax,ebx
    mov ebx,edx
    jmp L3
L4:
    pop edx
    pop ecx
    pop ebx
    ret
GCD ENDP
7.
BitwiseMultiply PROC
    push ecx
    push edx
    mov ecx,32
    xor edx,edx
L1:
    test ebx,1
    jz L2
    add edx,eax
L2:
    shl eax,1
    shr ebx,1
    loop L1
    mov eax,edx
    pop edx
    pop ecx
    ret
BitwiseMultiply ENDP
8.
AddPacked PROC
    push eax
    push ebx
    push ecx
    push esi
    push edi
    push edx
    xor ebx,ebx
    dec ecx
L1:
    mov al,[esi+ecx]
    mov ah,[edi+ecx]
    mov dl,al
    and dl,0Fh
    mov dh,ah
    and dh,0Fh
    add dl,dh
    add dl,bl
    xor bl,bl
    cmp dl,10
    jl L2
    sub dl,10
    mov bl,1
L2:
    mov cl,al
    shr cl,4
    mov ch,ah
    shr ch,4
    add cl,ch
    add cl,bl
    xor bl,bl
    cmp cl,10
    jl L3
    sub cl,10
    mov bl,1
L3:
    shl cl,4
    or cl,dl
    mov [edx+ecx],cl
    or ecx,ecx
    jz L4
    dec ecx
    jmp L1
L4:
    pop edx
    pop edi
    pop esi
    pop ecx
    pop ebx
    pop eax
    ret
AddPacked ENDP
